---
title: 如何从0到1搭建部署个人网站
date: 2024-06-02
---

# 如何从0到1开发部署个人网站

## 一、前言

### 1.1 [成品展示](https://www.leslie.xin)

### 1.2 技术栈

- 前端: Vue3 + Typescript + Vite
- 后端: Koa2 + Typescript + MySQL



## 二、本地环境准备

- node
- mysql

## 三、前端部分

### 3.1 搭架子

1. 初始化项目

   ```bash
   npm create vite
   ```

2. 配置项目环境

    1. 集成`type/node`

       ```bash
       npm i @types/node -D
       ```

    2. 编辑`tsconfig.json`

       ```
       
       ```

    3. 编辑`vite.config.json`

       ```javascript
       // vite.config.json
       import { defineConfig } from 'vite'
       import vue from '@vitejs/plugin-vue'
       import { resolve } from 'path'
       
       export default defineConfig({
         server: {
           host: '0.0.0.0', // 本地启动后，同一局域网都可通过ip访问
           proxy: { // 代理配置
             '/api': {
               target: 'your http address',
               changeOrigin: true,
               rewrite: (path) => path.replace(/^\/api/, '')
             }
           }
         },
         plugins: [vue()],
         resolve: {
           alias: { // 别名
             '@': resolve(__dirname, 'src')
           }
         }
       })
       ```

3. 集成vue-router

   > SPA(single page application)是指整个应用只有一个页面，vue-router的作用就是单页面应用的页面跳转(路由跳转)。

    1. 安装

       ```bash
       npm i vue-router -S
       ```

    2. 引入

       ```typescript
       // main.ts
       import { createApp } from 'vue'
       import App from '@/App.vue'
       import router from '@/router'
       
       const app = createApp(App)
       app.use(router)
       
       app.mount('#app')
       ```

       ```typescript
       // router/index.ts
       import { createRouter, createWebHistory } from 'vue-router'
       
       const router = createRouter({
         history: createWebHistory(import.meta.env.BASE_URL),
         routes: [
           {
               path: '/',
               redirect: '/home'
               },
             {
               path: '/home',
               name: 'home',
               component: () => import('@/view/Home/index.vue')
               },
           ...... // more routes
         ]
       })
       
       export default router
       ```

    3. 使用

       ```typescript
       // router/index.ts
       import { createRouter, createWebHistory } from 'vue-router'
       import usePermission from '@/hooks/usePermission'
       import { normalRoutes, authRoutes } from './config'
       import type { RouterScrollBehavior } from 'vue-router'
       
       // 当meta.keepAlive为true时 保证从其他页面返回该页面时，滚动条还能继续呆在当初的位置
       const scrollBehavior: RouterScrollBehavior = (to, _, savedPosition) => {
         if (savedPosition && to.meta.keepAlive) return savedPosition
         return { left: 0, top: 0 }
       }
       
       // 路由拆分为普通路由和权限路由 用作前端的路由权限控制
       const router = createRouter({
         history: createWebHistory(import.meta.env.BASE_URL),
         scrollBehavior,
         routes: [...normalRoutes, ...authRoutes]
       })
       
       // 全局路由守卫 - 在每次路由跳转的时候触发
       // 这里是在跳转一些需要权限的路由时，判断是否有权限，无权则跳转到NotFound页面
       router.beforeEach(to => {
         const auth = usePermission('normal')
         if (!auth && authRoutes.some(route => route.path === to.path)) return '/NotFound'
       })
       
       export default router
       ```

4. 集成pinia

   > 全局状态管理工具

    1. 安装

       ```bash
       npm i pinia -S
       ```

    2. 引入

       ```typescript
       // main.ts
       import { createApp } from 'vue'
       import { createPinia } from 'pinia'
       import App from '@/App.vue'
       import router from '@/router'
       
       const pinia = createPinia()
       
       const app = createApp(App)
       app.use(router)
       app.use(pinia)
       
       app.mount('#app')
       ```

    3. 使用

        1. 定义userStore

           ```typescript
           // store/useUserStore.ts
           import { ref } from 'vue'
           import { useRouter } from 'vue-router'
           import { defineStore } from 'pinia'
           import { login, register } from '@/service/user'
           import type { LoginParams, LoginRes, RegisterParams, UserPermissionType } from '@/service/user/type'
           
           export const useUserStore = defineStore(
             'user',
             () => {
               const router = useRouter()
           
               const userInfo = ref<Omit<LoginRes, 'token'>>()
           
               const isLogin = ref(false) // 当前是否为已登录状态
               const token = ref<string>()
               const permission = ref<UserPermissionType>() // 用户权限
           
               // 注册
               const handleRegister = async (registerParams: RegisterParams) => {
                 await register(registerParams)
                 await handleLogin(registerParams)
               }
           
               // 登录
               const handleLogin = async (loginParams: LoginParams) => {
                 const { data } = await login(loginParams)
                 userInfo.value = data
                 isLogin.value = true
                 token.value = data.token
                 permission.value = data.permission
               }
           
               // 登出
               const handleLogout = async () => {
                 userInfo.value = undefined
                 isLogin.value = false
                 permission.value = undefined
                 await router.push('/home')
               }
           
               // 暴露出去
               return {
                 userInfo,
                 isLogin,
                 token,
                 permission,
                 handleRegister,
                 handleLogin,
                 handleLogout
               }
             }
           )
           ```

        2. 消费userStore

           ```vue
           <template>
             <el-button
               type='primary'
               size='small'
               link
               @click='login'
             >
               login
             </el-button>
           </template>
           
           <script setup lang='ts'>
           import { ref, watch, computed } from 'vue'
           import { storeToRefs } from 'pinia'
           import { useUserStore } from '@/store/useUserStore'
           
           const userStore = useUserStore()
           
           // 变量必须通过storeToRefs转化成ref，不然会丢失视图层的响应式
           const { isLogin } = storeToRefs(userStore)
           
           // function可以直接结构
           const { handleLogin } = userStore
           
           const login = async () => {
             if (isLogin) return
             await handleLogin()
           }
           
           </script>
           
           ```

    4. 持久化

       > 全局状态管理都有一个通病，就是刷新页面后(app卸载后)，所有的store数据都会丢失，所以需要数据持久化，这里我选择的用三方轮子 `pinia-plugin-persistedstate`

        1. 安装

           ```bash
           npm i pinia-plugin-persistedstate -S
           ```

        2. 引入

           ```typescript
           // main.ts
           import { createApp } from 'vue'
           import { createPinia } from 'pinia'
           import piniaPluginPersistedState from 'pinia-plugin-persistedstate'
           import App from '@/App.vue'
           import router from '@/router'
           
           const pinia = createPinia()
           pinia.use(piniaPluginPersistedState)
           
           const app = createApp(App)
           app.use(router)
           app.use(pinia)
           
           app.mount('#app')
           ```

        3. 使用

           ```typescript
           // store/useUserStore.ts
           import { ref } from 'vue'
           import { useRouter } from 'vue-router'
           import { defineStore } from 'pinia'
           import { login, register } from '@/service/user'
           import type { LoginParams, LoginRes, RegisterParams, UserPermissionType } from '@/service/user/type'
           
           export const useUserStore = defineStore(
             'user',
             () => {
               const router = useRouter()
           
               const userInfo = ref<Omit<LoginRes, 'token'>>()
           
               const isLogin = ref(false) // 当前是否为已登录状态
               const token = ref<string>()
               const permission = ref<UserPermissionType>() // 用户权限
           
               // 注册
               const handleRegister = async (registerParams: RegisterParams) => {
                 await register(registerParams)
                 await handleLogin(registerParams)
               }
           
               // 登录
               const handleLogin = async (loginParams: LoginParams) => {
                 const { data } = await login(loginParams)
                 userInfo.value = data
                 isLogin.value = true
                 token.value = data.token
                 permission.value = data.permission
               }
           
               // 登出
               const handleLogout = async () => {
                 userInfo.value = undefined
                 isLogin.value = false
                 permission.value = undefined
                 await router.push('/home')
               }
           
               // 暴露出去
               return {
                 userInfo,
                 isLogin,
                 token,
                 permission,
                 handleRegister,
                 handleLogin,
                 handleLogout
               }
             },
             {
               persist: {
                 key: 'userStore',
                 storage: sessionStorage // sessionStorage or localStorage
               }
             }
           )
           ```



5. 集成css预处理器

   ```bash
   # less
   npm i less -S
   
   # sass
   npm i sass -S
   ```

6. 集成axios

    1. 安装

       ```bash
       npm i axios -S
       ```

    2. 封装

       ```typescript
       // axios/axios.ts
       import axios from 'axios'
       import message from '@/utils/message'
       import type { AxiosResponse, AxiosError, AxiosInstance } from 'axios'
       import type { Res, HttpConfig } from './type'
       
       class Http {
         instance: AxiosInstance
         showSuccessMsg: boolean // 请求成功后是否自动toast success msg
         showErrorMsg: boolean // 请求失败后是否自动toast error msg
       
         constructor(config: HttpConfig) {
           this.instance = axios.create(config)
           this.showSuccessMsg = config.showSuccessMsg ?? false
           this.showErrorMsg = config.showErrorMsg ?? false
           this.loading = config.loading ?? false
       
           this.instance.interceptors.request.use(
             (config) => {
               return config
             },
             (error: AxiosError) => {
               return error
             }
           )
       
           this.instance.interceptors.response.use(
             (response: AxiosResponse) => {
               if (this.showSuccessMsg) message.success(response.data.msg)
               return Promise.resolve(response.data)
             },
             (error: AxiosError<Res>) => {
               if (error!.response?.data.code) {
                 if (this.showErrorMsg) message.error(error.response.data.msg)
                 return Promise.reject(error.response?.data.msg)
               }
               message.error('Network Error!')
               return Promise.reject('Network Error!')
             }
           )
       
           this.instance.interceptors.request.use(
             config.interceptors?.requestInterceptor as any,
             config.interceptors?.requestInterceptorCatch
           )
           this.instance.interceptors.response.use(
             config.interceptors?.responseInterceptor,
             config.interceptors?.responseInterceptorCatch
           )
         }
       
         request<T = unknown>(config: HttpConfig<T>) {
           return new Promise<T>((resolve, reject) => {
             // 单个接口
             if (config.interceptors?.requestInterceptor) {
               config = config.interceptors.requestInterceptor(config)
             }
             if (config.showSuccessMsg === true || config.showSuccessMsg === false) {
               this.showSuccessMsg = config.showSuccessMsg
             }
             if (config.showErrorMsg === true || config.showErrorMsg === false) {
               this.showErrorMsg = config.showErrorMsg
             }
             this.instance
               .request<unknown, T>(config)
               .then((res) => {
                 if (config.interceptors?.responseInterceptor) {
                   res = config.interceptors.responseInterceptor(res)
                 }
                 resolve(res)
               })
               .catch((error: Error) => {
                 reject(error)
               })
           })
         }
       
         get<T = unknown>(config: HttpConfig<T>) {
           return this.request<T>({ ...config, method: 'GET' })
         }
       
         post<T = unknown>(config: HttpConfig<T>) {
           return this.request<T>({ ...config, method: 'POST' })
         }
       
         put<T = unknown>(config: HttpConfig<T>) {
           return this.request<T>({ ...config, method: 'PUT' })
         }
       
         patch<T = unknown>(config: HttpConfig<T>) {
           return this.request<T>({ ...config, method: 'PATCH' })
         }
       
         delete<T = unknown>(config: HttpConfig<T>) {
           return this.request<T>({ ...config, method: 'DELETE' })
         }
       }
       
       export default Http
       
       ```

    3. 使用

       ```typescript
       // axios/http.ts
       import { storeToRefs } from 'pinia'
       import { useUserStore } from '@/store/useUserStore'
       import Http from './axios'
       import { baseURLMap } from './config'
       import type { EnvType } from '@/service/axios/type'
       
       export default new Http({
         baseURL: baseURLMap[import.meta.env.MODE as EnvType],
         timeout: 10000,
         interceptors: {
           requestInterceptor(config) {
             const userStore = useUserStore()
             const { isLogin, token } = storeToRefs(userStore)
             if (isLogin.value && token.value) config.headers!.authorization = 'Bearer ' + token.value
             return config
           }
         }
       })
       ```

       ```typescript
       import http from '@/service/axios/http'
       import type { Res } from '@/service/axios/type'
       import type { LoginParams, LoginRes, RegisterParams } from './type'
       
       export function register(data: RegisterParams): Promise<Res> {
         return http.post({
           url: '/user/register',
           data,
           showSuccessMsg: true,
           showErrorMsg: true
         })
       }
       
       export function login(data: LoginParams) {
         return http.post<Res<LoginRes>>({
           url: '/user/login',
           data,
           showSuccessMsg: true,
           showErrorMsg: true
         })
       }
       ```



### 3.2 开发

> 画想画的页面



### 3.3 打包

```bash
npm run build
```



## 四、后端部分

### 4.1 搭架子

1. 初始化项目

   ```bash
   # 新建一个文件夹
   npm init
   ```

2. 集成 typescript 开发环境

   ```bash
   npm i typescript ts-node-dev
   ```

3. 集成koa环境

    1. 安装

       ```bash
       # 使用koa后端框架
       npm i koa -S 
       
       # 后端路由
       npm i koa-router -S
       
       # 用作解析post请求的body参数
       npm i koa-bodyparser -S
       
       # 用作解析form-data文件
       npm i koa-multer
       
       # 用作静态资源服务器
       npm i koa-static
       
       # 用作解决跨域问题
       npm i koa2-cors
       ```

    2. 引入

       ```typescript
       // router/index.ts
       import fs from 'fs'
       import path from 'path'
       import type Koa from 'koa'
       import type Router from 'koa-router'
       
       // 动态注册路由
       const useRoutes = (app: Koa) => {
         fs.readdirSync(__dirname).forEach((module) => {
           if (module === 'index.ts') return
           const router: Router = require(path.join(__dirname, module)).default
           app.use(router.routes())
           app.use(router.allowedMethods())
         })
       }
       
       export default useRoutes
       ```

       ```typescript
       // app/index.ts
       import path from 'path'
       import Koa from 'koa'
       import bodyParse from 'koa-bodyparser'
       import cors from 'koa2-cors'
       import staticFiles from 'koa-static'
       import useRoutes from '@/router'
       import errorHandler from './errorHandler'
       
       const app = new Koa()
       
       app.use(cors())
       
       app.use(bodyParse())
       
       app.use(staticFiles(path.resolve(__dirname, '..', '../public')))
       
       useRoutes(app)
       
       export default app
       ```

4. 集成开发体验类工具

    1. 安装

       ```bash
       # 设置alias别名，import好引入
       npm i module-alias
       
       # 解析.env环境变量
       npm i dotenv
       ```

    2. 使用

       ```typescript
       // config.ts
       import fs from 'fs'
       import path from 'path'
       import dotenv from 'dotenv'
       
       type EnvType = 'test' | 'development' | 'production'
       
       const dotEnvPathMap = {
         test: '.env.test',
         development: '.env.development',
         production: '.env.production'
       } as const
       
       dotenv.config({ path: dotEnvPathMap[process.env.NODE_ENV as EnvType] })
       
       export const APP_HOST = process.env.APP_HOST
       export const APP_PORT = process.env.APP_PORT
       export const MYSQL_HOST = process.env.MYSQL_HOST
       
       export const MYSQL_PORT = Number(process.env.MYSQL_PORT)
       export const MYSQL_DATABASE = process.env.MYSQL_DATABASE
       export const MYSQL_USER = process.env.MYSQL_USER
       export const MYSQL_PASSWORD = process.env.MYSQL_PASSWORD
       
       export const FILE_PATH = process.env.FILE_PATH
       ```

5. 集成mysql2

    1. 安装

       ```bash
       npm i mysql2 -S
       ```

    2. 连接

       ```shell
       # .env
       APP_HOST=localhost
       APP_PORT=8000
       
       MYSQL_HOST=127.0.0.1
       MYSQL_PORT=3306
       MYSQL_DATABASE=database_name
       MYSQL_USER=database_user
       MYSQL_PASSWORD=database_password
       
       FILE_PATH=http://localhost:8000/images
       ```

       ```typescript
       // database.ts
       import { createPool, PoolConnection } from 'mysql2'
       import {
         MYSQL_HOST,
         MYSQL_PORT,
         MYSQL_DATABASE,
         MYSQL_USER,
         MYSQL_PASSWORD
       } from './config'
       
       export const useDatabase = () => {
         // 创建连接池
         const connection = createPool({
           host: MYSQL_HOST,
           port: MYSQL_PORT,
           database: MYSQL_DATABASE,
           user: MYSQL_USER,
           password: MYSQL_PASSWORD
         })
       
         // 连接数据库
         const connectDatabase = async () => {
           connection.getConnection((err: Error | null, connection: PoolConnection) => {
             if (err) return console.log('connect failed')
             console.log('connect success')
           })
         }
       
         // 断开数据库
         const disconnectDatabase = async () => {
           connection.end((err: Error | null) => {
             if (err) return console.log('disconnect failed')
             console.log('disconnect success')
           })
         }
       
         // 返回
         return {
           connectDatabase,
           clearDatabase,
           disconnectDatabase,
           execute: connection.promise().execute.bind(connection.promise())
         }
       }
       ```

    3. 使用

       ```typescript
       import { querySelect, queryInsert } from '@/utils'
       import type { UserInfo, UserPermissionType } from '@/types'
       
       export const getUserInfo = async (username: string): Promise<UserInfo | null> => {  
         const { connectDatabase, disconnectDatabase, execute } = useDatabase()
         await connectDatabase()
         const statement = `
           SELECT 'id', 'username', 'password', 'permission'
           FROM users
           WHERE username = ${username}
            `
         const res = await execute(statement)
         await disconnectDatabase()
         return users.length ? users[0] : null
       }
       ```

6. 错误处理

    1. handler

       ```typescript
       const errorHandler = (error: Error, ctx: Context) => {
         ctx.status = ctx.errorStatus || 500
         ctx.body = xxx
       }
       ```

    2. 注册

       ```typescript
       // app/index.js
       import path from 'path'
       import Koa from 'koa'
       import bodyParse from 'koa-bodyparser'
       import cors from 'koa2-cors'
       import staticFiles from 'koa-static'
       import useRoutes from '@/router'
       import errorHandler from './errorHandler'
       
       const app = new Koa()
       
       app.use(cors())
       
       app.use(bodyParse())
       
       app.use(staticFiles(path.resolve(__dirname, '..', '../public')))
       
       useRoutes(app)
       
       app.on('error', errorHandler)
       
       export default app
       ```

    3. emitter

       ```typescript
       ctx.errorStatus = 500
       ctx.app.emit('error', new Error('xxx'), ctx)
       ```

### 4.2 开发

#### 开发案例

```typescript
// router/user/index.ts
import Router from 'koa-router'
import { verifyLoginParams } from '@/middleware'
import { handleLogin } from '@/controller'

const userRouter = new Router({ prefix: '/user' })

userRouter.post('/login', verifyLoginParams, handleLogin)

export default userRouter
```

```typescript
// middleware/user.middleware.ts
import { getUserInfo } from '@/service'
import { throwError, encrypt } from '@/utils'
import type { Context, Next } from 'koa'
import type { LoginParams } from '@/types'

export const verifyLoginParams = async (ctx: Context, next: Next) => {
  const { username, password } = ctx.request.body as Partial<LoginParams>
  if (!username) return throwError(ctx, 'Username Cannot Be Empty!', 400)
  if (!password) return throwError(ctx, 'Password Cannot Be Empty!', 400)
  const user = await getUserInfo(username)
  if (!user) return throwError(ctx, 'User Does Not Exists!', 400)
  if (user.password !== encrypt(password)) return throwError(ctx, 'Password Is Incorrect!', 400)
  ctx.user = user
  await next()
}
```

```typescript
// controller/user.controller.ts
import { sign } from 'jsonwebtoken'
import { throwError, useSuccessReturn } from '@/utils'
import { PRIVATE_KEY } from '@/app/config'
import type { Context } from 'koa'
import type { UserInfo } from '@/types'

export const handleLogin = async (ctx: Context) => {
  try {
    const { id, username, permission } = ctx.user as UserInfo
    const token = sign({ id, username, permission }, PRIVATE_KEY, {
      expiresIn: 60 * 60 * 24,
      algorithm: 'RS384'
    })
    ctx.body = useSuccessReturn({ id, username, permission, token }, 'Login Success!')
  } catch (e) {
    throwError(ctx, (e as Error).message, 500)
  }
}
```

```typescript
// service/user.service.ts
import { querySelect, queryInsert } from '@/utils'
import type { UserInfo, UserPermissionType } from '@/types'

export const getUserInfo = async (username: string): Promise<UserInfo | null> => {
  const users = await querySelect<UserInfo[]>({
    table: 'users',
    where: { username },
    columns: ['id', 'username', 'password', 'permission']
  })
  return users.length ? users[0] : null
}

export const createUser = async (username: string, password: string, permission: UserPermissionType) => {
  await queryInsert({
    table: 'users',
    data: {
      username,
      password,
      permission
    }
  })
}
```

#### 工具函数封装

##### 返回值相关

```typescript
export const useReturn = <Data = {}>(code: number, data: Data, msg: string) => {
  return { code, data, msg }
}

export const useSuccessReturn = <R = unknown>(result: R, message?: string) => {
  return useReturn(0, result ?? {}, message || 'Success!')
}

export const useErrorReturn = (message: string) => {
  return useReturn(1, {}, message)
}
```

##### 抛错

```typescript
import type { Context } from 'koa'

/**
 * Global error emitter
 * @400: Bad Request
 * @401: Unauthorized
 * @403: Forbidden
 * @409: Conflict
 * @500: Internal Server Error
 */
export const throwError = (ctx: Context, errorMsg: string, errorStatus: number = 500) => {
  ctx.errorStatus = errorStatus
  ctx.app.emit('error', new Error(errorMsg), ctx)
}
```

##### SQL相关

```typescript
import { useDatabase } from '@/app/database'

type Table = 'users' | 'blogs' | 'projects' | 'files'

interface SelectQuery {
  table: Table,
  where?: Record<string, any>,
  columns: string[]
}

interface InsertQuery {
  table: Table,
  data: Record<string, any>
}

interface UpdateQuery {
  table: Table,
  where: Record<string, any>,
  update: Record<string, any>
}

interface DeleteQuery {
  table: Table,
  where: Record<string, any>
}

// 查询
export const querySelect = async <T = unknown>(query: SelectQuery) => {
  const { connectDatabase, disconnectDatabase, execute } = useDatabase()
  await connectDatabase()
  const { table, where = {}, columns } = query
  const whereClause = Object.keys(where).length > 0
    ? `WHERE ${Object.keys(where).map(key => `${key} = ?`).join(' AND ')}`
    : ''
  const statement = `
    SELECT ${columns.join(',')}
    FROM ${table}
    ${whereClause}
 `
  const res = await execute(statement, Object.values(where))
  await disconnectDatabase()
  return res[0] as unknown as Promise<T>
}

// 新增
export const queryInsert = async (query: InsertQuery) => { // TODO - 消费queryInsert时可以对query中的data进行类型断言
  const { connectDatabase, disconnectDatabase, execute } = useDatabase()
  await connectDatabase()
  const { table, data } = query
  const keys = Object.keys(data)
  const values = Object.values(data)
  const statement = `
    INSERT INTO ${table}
    (${keys.join(',')}) VALUES (${keys.map(() => '?').join(',')})
  `
  await execute(statement, values)
  await disconnectDatabase()
}

// 修改
export const queryUpdate = async (query: UpdateQuery) => {
  const { connectDatabase, disconnectDatabase, execute } = useDatabase()
  await connectDatabase()
  const { table, where, update } = query
  const statement = `
    UPDATE ${table}
    SET ${Object.keys(update).map(key => `${key} = ?`).join(',')}
    WHERE ${Object.keys(where).map(key => `${key} = ?`).join(' AND ')}
  `
  await execute(statement, [...Object.values(update), ...Object.values(where)])
  await disconnectDatabase()
}

// 删除 - 这里是物理删除 正确的应该是维护enable字段去做逻辑删除
export const queryDelete = async (query: DeleteQuery) => {
  const { connectDatabase, disconnectDatabase, execute } = useDatabase()
  await connectDatabase()
  const { table, where } = query
  const statement = `
    DELETE FROM ${table}
    WHERE ${Object.keys(where).map(key => `${key} = ?`).join(' AND ')}
  `
  await execute(statement, Object.values(where))
  await disconnectDatabase()
}
```





## 五、服务器相关

1. 首先要准备一个服务器，阿里云、腾讯云、华为云等都可以，这里我以腾讯云-centOS8镜像为示例。

2. 打通本地与服务器连接，能在本地通过terminal直接连接服务器。

    1. 创建本地密钥
    2. 打开腾讯云服务器管理页面![image-20240329224432375]()
    3. 创建密钥![image-20240329224601872]()
    4. terminal连接![image-20240329224652908]()

3. 服务器安装node、nginx、mysql

   ```bash
   # node
   sudo yum install -y nodejs
   
   # nginx
   sudo yum install -y nginx
   
   # mysql
   sudo yum localinstall mysql80-community-release-el8-1.noarch.rpm # 下载安装 MySQL Yum 仓库
   sudo yum install mysql-community-server -y # 安装 MySQL 8 社区服务器
   ```

4. 将项目扔到服务器上，推荐先使用FTP可视化软件操作，如FileZilla、ForkLift等。我是在`/home/blog`下建了两个文件夹，分别放前端静态资源和后端服务。

5. 配置nginx，config文件在`/etc/nginx/nginx.conf`，可使用vim、nano直接修改，也可以本地修改了在通过FTP扔到服务器。

   ```nginx
   server {
       listen       80 default_server; # 监听本地80端口
       listen       [::]:80 default_server;
       server_name  localhost;
       root         /home/blog/ThousandSunny; # 这里放前端项目的根路径
   
       include /etc/nginx/default.d/*.conf;
   
       # 映射接口到本地的8000端口
       location /api/ {
           rewrite ^/api(/.*)$ $1 break;
           proxy_pass http://127.0.0.1:8000;
           proxy_set_header Host $host;
           proxy_set_header X-Real-IP $remote_addr;
           proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
           proxy_set_header X-Forwarded-Proto $scheme;
       }
   
       location / {
           index index.html;
           try_files $uri $uri/ /index.html; # 防止在其他路由刷新丢失页面
       }
   
       error_page 404 /404.html;
           location = /40x.html {
       }
   }
   ```

6. 启动nginx、mysql

   ```bash
   # 启动nginx
   nginx
   
   # 重启nginx
   nginx -s relod
   
   # mysql
   mysql.server start
   ```

7. 安装pm2，因为在服务端启动后端服务后，关闭terminal会断掉后端服务，所以需要去守护进程

   ```bash
   npm install pm2@latest --global
   ```

8. 后端项目根目录新增`ecosystem.config.js`文件

   ```javascript
   module.exports = {
     apps: [
       {
         name: 'GoingMerry', // 进程名称
         script: './src/main.ts', // 后端入口文件
         interpreter: './node_modules/.bin/ts-node',
         exec_mode: 'cluster',
         env: {
           NODE_ENV: 'production' // pm2启动时注入的环境变量
         },
         log_date_format: 'YYYY-MM-DD HH:mm:ss', // 日志日期格式
         out_file: './public/out.log', // 日志输出
         error_file: './public/error.log' // 报错日志输出
       }
     ]
   }
   ```

9. 进入后端根目录，pm2启动![image-20240329231107397]()

10. 启动完成，浏览器输入服务器ip查看战果![image-20240329231207839]()




## 六、自动化部署

~~埋个坑，后续回来填土。~~
